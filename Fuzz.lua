function msg(m)
  return reaper.ShowConsoleMsg(tostring(m) .. "\n")
end

function get_script_path()
  local info = debug.getinfo(1, "S")
  local script_path = info.source:match [[^@?(.*[\/])[^\/]-$]]
  return script_path
end

local script_path = get_script_path()
package.path = package.path .. ";" .. script_path .. "?.lua"

require "fuzzysort"
require "benchmark"
benchmark.bypass = true

-- Script generated by Lokasenna's GUI Builder

local lib_path = reaper.GetExtState("Lokasenna_GUI", "lib_path_v2")
if not lib_path or lib_path == "" then
  reaper.MB(
    "Couldn't load the Lokasenna_GUI library. Please install 'Lokasenna's GUI library v2 for Lua', available on ReaPack, then run the 'Set Lokasenna_GUI v2 library path.lua' script in your Action List.",
    "Whoops!",
    0
  )
  return
end
loadfile(lib_path .. "Core.lua")()

GUI.req("Classes/Class - Listbox.lua")()
GUI.req("Classes/Class - Textbox.lua")()
-- If any of the requested libraries weren't found, abort the script.
if missing_lib then
  return 0
end

GUI.name = "Fuzz"
GUI.x, GUI.y, GUI.w, GUI.h = 0, 0, 1800, 480
GUI.anchor, GUI.corner = "screen", "C"
GUI.fonts[3] = {"Consolas", 35}

GUI.New(
  "results",
  "Listbox",
  {
    z = 11,
    x = 80,
    y = 80,
    w = 1700,
    h = 350,
    list = {},
    multi = false,
    caption = "",
    font_a = 3,
    font_b = 3,
    color = "txt",
    col_fill = "elm_fill",
    bg = "elm_bg",
    cap_bg = "wnd_bg",
    shadow = false,
    pad = 4
  }
)

GUI.New(
  "input",
  "Textbox",
  {
    z = 11,
    x = 80,
    y = 32,
    w = 1700,
    h = 35,
    caption = "",
    cap_pos = "left",
    color = "txt",
    bg = "wnd_bg",
    shadow = false,
    font_a = 3,
    font_b = 3,
    pad = 4,
    undo_limit = 20
  }
)
-- pre-set focus on textbox
GUI.elms.input.focus = true

-- Modify this instance of Textbox to ignore Up and Down arrow keys:
GUI.elms.input.keys[GUI.chars.UP] = function()
end
GUI.elms.input.keys[GUI.chars.DOWN] = function()
end

-- This function iterates over a fuzzysort results table, sorted by score
function sortedResults(t)
  local clonedTable = {}
  for n in pairs(t) do
    table.insert(clonedTable, n)
  end

  function sortFunction(a, b)
    return t[a].score > t[b].score
  end

  table.sort(clonedTable, sortFunction)
  local i = 0
  local iter = function()
    i = i + 1
    if clonedTable[i] == nil then
      return nil
    else
      return clonedTable[i], t[clonedTable[i]]
    end
  end
  return iter
end

function resultsForListbox(results)
  local retval = {}
  for i, result in ipairs(results) do
    table.insert(retval, result.target)
  end
  return retval
end

local inputString = ""
local searchString = ""

-- Enumerate actions to search through
function buildActionsTable()
  local ret = 1
  local actionIndex = 0
  local actionsTable = {}
  local theOtherString = ""

  while ret > 0 do
    local string = ""
    ret, string = reaper.CF_EnumerateActions(0, actionIndex, theOtherString)
    table.insert(actionsTable, {code = ret, name = string})
    actionIndex = actionIndex + 1
  end

  return actionsTable
end
benchmark.start("build actions table")
local actionsTable = buildActionsTable()
benchmark.stop("build actions table")

-- Make list of plugin chain files
function buildPluginsTable()
  local pluginsPath = reaper.GetResourcePath() .. "/FXChains/"
  local pluginsTable = {}

  function scanDirectory(path)
    local directoryIndex = 0
    while true do
      local subPath = reaper.EnumerateSubdirectories(path, directoryIndex)
      directoryIndex = directoryIndex + 1
      if subPath == nil then
        break
      end
      scanDirectory(path .. subPath)
    end

    local fileIndex = 0
    while true do
      local file = reaper.EnumerateFiles(path, fileIndex)
      fileIndex = fileIndex + 1
      if file == nil then
        break
      end
      local subDirectories = string.sub(path, #pluginsPath + 1, #path) .. "/"
      local filePlusSub = subDirectories .. string.sub(file, 1, #file - 9)
      pluginsTable[#pluginsTable + 1] = {name = filePlusSub}
    end
  end

  scanDirectory(pluginsPath)

  return pluginsTable
end
benchmark.start("build plugin table")
local pluginsTable = buildPluginsTable()
benchmark.stop("build plugin table")

local selectedIndex = 1
local resultsList = {}
local mode = "actions"

function listen()
  if GUI.char == GUI.chars.UP then
    selectedIndex = selectedIndex - 1
    selectedIndex = selectedIndex >= 1 and selectedIndex or 1
    updateResultsBox()
  end

  if GUI.char == GUI.chars.DOWN then
    selectedIndex = selectedIndex + 1
    selectedIndex = selectedIndex <= #resultsList and selectedIndex or #resultsList
    updateResultsBox()
  end

  if GUI.char == GUI.chars.RETURN then
    if mode == "actions" then
      local commandID = resultsList[selectedIndex].obj.code
      reaper.Main_OnCommand(commandID, 0)
    elseif mode == "plugins" then
      -- open plugin
      local selectedTrack = reaper.GetSelectedTrack2(0, 0, true)
      if selectedTrack ~= nil then
        local fxName = resultsList[selectedIndex].obj.name .. ".RfxChain"
        local effectIndex = reaper.TrackFX_AddByName(selectedTrack, fxName, false, -1)
        reaper.TrackFX_SetOpen(selectedTrack, effectIndex, true)
      else
        msg("Error: No track selected")
      end
    end
    gfx.quit()
  end

  local prevSearchStringLength = #searchString

  if GUI.Val("input") ~= inputString then
    inputString = GUI.Val("input")

    if string.sub(inputString, 1, 1) == "$" then
      mode = "plugins"
      searchString = string.sub(inputString, 2)
    else
      searchString = inputString
    end

    benchmark.start("fuzzysort")

    local searchTable = {}
    if #searchString > 1 and #searchString > prevSearchStringLength then
      -- only search within current results for efficiency
      for _, result in pairs(resultsList) do
        searchTable[#searchTable + 1] = result.obj
      end
    else
      if mode == "actions" then
        searchTable = actionsTable
      elseif mode == "plugins" then
        searchTable = pluginsTable
      end
    end

    local results = fuzzysort.go(searchString, searchTable, {key = "name"})

    benchmark.stop("fuzzysort")

    
    benchmark.start("results list")
    
    resultsList = {}
    for i, result in sortedResults(results) do
      resultsList[#resultsList + 1] = result
    end
    
    benchmark.stop("results list")
    
    -- Now that resultsList might be shorter, make sure our selectedIndex is still within bounds
    selectedIndex = selectedIndex <= #resultsList and selectedIndex or #resultsList

    benchmark.start("udpate results")

    GUI.elms.results.list = resultsForListbox(resultsList)
    updateResultsBox()

    benchmark.stop("udpate results")
  end
end

function updateResultsBox()
  GUI.Val("results", selectedIndex)
  GUI.redraw_z[0] = true
end

GUI.Init()
GUI.freq = 0
GUI.func = listen
GUI.Main()
