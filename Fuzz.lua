function msg(m)
  return reaper.ShowConsoleMsg(tostring(m) .. "\n")
end

function get_script_path()
  local info = debug.getinfo(1, "S")
  local script_path = info.source:match [[^@?(.*[\/])[^\/]-$]]
  return script_path
end

local script_path = get_script_path()
package.path = package.path .. ";" .. script_path .. "?.lua"

require "fuzzysort"

function benchmark(name, func)
  local startTime = os.clock()
  local result = func()
  local endTime = os.clock()

  msg("BM - " .. name .. ": " .. endTime - startTime)

  return result
end

-- Script generated by Lokasenna's GUI Builder

local lib_path = reaper.GetExtState("Lokasenna_GUI", "lib_path_v2")
if not lib_path or lib_path == "" then
  reaper.MB(
    "Couldn't load the Lokasenna_GUI library. Please install 'Lokasenna's GUI library v2 for Lua', available on ReaPack, then run the 'Set Lokasenna_GUI v2 library path.lua' script in your Action List.",
    "Whoops!",
    0
  )
  return
end
loadfile(lib_path .. "Core.lua")()

GUI.req("Classes/Class - Listbox.lua")()
GUI.req("Classes/Class - Textbox.lua")()
-- If any of the requested libraries weren't found, abort the script.
if missing_lib then
  return 0
end

GUI.name = "Fuzz"
GUI.x, GUI.y, GUI.w, GUI.h = 0, 0, 1800, 480
GUI.anchor, GUI.corner = "screen", "C"
GUI.fonts[3] = {"Consolas", 35}

GUI.New(
  "results",
  "Listbox",
  {
    z = 11,
    x = 80,
    y = 80,
    w = 1700,
    h = 350,
    list = {},
    multi = false,
    caption = "",
    font_a = 3,
    font_b = 3,
    color = "txt",
    col_fill = "elm_fill",
    bg = "elm_bg",
    cap_bg = "wnd_bg",
    shadow = false,
    pad = 4
  }
)

GUI.New(
  "input",
  "Textbox",
  {
    z = 11,
    x = 80,
    y = 32,
    w = 1700,
    h = 35,
    caption = "",
    cap_pos = "left",
    color = "txt",
    bg = "wnd_bg",
    shadow = false,
    font_a = 3,
    font_b = 3,
    color = "txt",
    bg = "wnd_bg",
    pad = 4,
    undo_limit = 20
  }
)
-- pre-set focus on textbox
GUI.elms.input.focus = true

-- Modify this instance of Textbox to ignore Up and Down arrow keys:
GUI.elms.input.keys[GUI.chars.UP] = function(self)
  return self
end
GUI.elms.input.keys[GUI.chars.DOWN] = function(self)
  return self
end

-- This function iterates over a fuzzysort results table, sorted by score
function sortedResults(t)
  local clonedTable = {}
  for n in pairs(t) do
    table.insert(clonedTable, n)
  end

  function sortFunction(a, b)
    return t[a].score > t[b].score
  end

  table.sort(clonedTable, sortFunction)
  local i = 0
  local iter = function()
    i = i + 1
    if clonedTable[i] == nil then
      return nil
    else
      return clonedTable[i], t[clonedTable[i]]
    end
  end
  return iter
end

local searchString = ""
local testTable = {"fumbledon", "fried turkey rum", "flutes 39", "feed your magazine"}

-- Enumerate actions to search through
local ret = 1
local actionIndex = 0
local actionsTable = {}
local theOtherString = "yer"

while ret > 0 do
  local string = ""
  ret, string = reaper.CF_EnumerateActions(0, actionIndex, theOtherString)
  table.insert(actionsTable, string)
  actionIndex = actionIndex + 1
end

local selectedIndex = 1
local resultsList = {}

function listen()
  -- local char = GUI.char
  -- local character = string.char(char)

  -- TODO: support backspace, etc
  -- TODO: maybe this should be done with the text input
  -- if char >= 32 and char <= 126 then
  --   searchString = searchString .. character
  --   GUI.Val('input', searchString)

  --   GUI.elms.results.list = {searchString}
  --   GUI.redraw_z[0] = true
  -- end

  if GUI.char == 30064 then -- down arrow
    selectedIndex = selectedIndex - 1
    updateResultsBox()
  end
  if GUI.char == 1685026670 then -- up arrow
    selectedIndex = selectedIndex + 1
    updateResultsBox()
  end

  if GUI.Val("input") ~= searchString then
    searchString = GUI.Val("input")

    -- msg('shit changed')
    local results =
      benchmark(
      "fuzzysort",
      function()
        return fuzzysort.go(searchString, actionsTable)
      end
    )

    benchmark(
      "sortResults",
      function()
        for i, result in sortedResults(results) do
          resultsList[#resultsList + 1] = result.target
        end
      end
    )

    benchmark(
      "update results",
      function()
        GUI.elms.results.list = resultsList
        updateResultsBox()
      end
    )
  end
end

function updateResultsBox()
  GUI.Val("results", selectedIndex)
  GUI.redraw_z[0] = true
end

GUI.Init()
GUI.freq = 0
GUI.func = listen
GUI.Main()
